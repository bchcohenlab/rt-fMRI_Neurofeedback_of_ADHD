# -*- coding: utf-8 -*-
"""MW_localizer_registered_mask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mjqnKS9-R1WDNB5QTKhgoU9130OgvQ8W
"""

import os
import sys
import tempfile
import numpy as np
import pandas as pd
import nibabel as nib 
import datetime #for generating timestamps
from numpy import array
import matplotlib.pyplot as plt
from nilearn import image, masking
from nilearn.image import concat_imgs, mean_img
from nilearn.glm.first_level import FirstLevelModel
from nilearn.plotting import plot_anat, plot_img, plot_stat_map, plot_design_matrix, plot_contrast_matrix

sys.path.append('/home/rt/rt-cloud/rtCommon/')
sys.path.append('/home/rt/rt-cloud/')
sys.path.append('/home/rt/rt-cloud/tests/')

tmpPath = tempfile.gettempdir() # specify directory for temporary files
currPath = os.path.dirname(os.path.realpath(__file__)) #'.../rt-cloud/projects/project_name'
rootPath = os.path.dirname(os.path.dirname(currPath)) #'.../rt-cloud' 
dicomParentPath = '/home/rt/sambashare/' #.../rt-cloud/projects/project_name/dicomDir/
outPath = rootPath+'/outDir' #'.../rt-cloud/outDir/'

# Get the list of directories
directories = [d for d in os.listdir(dicomParentPath) if os.path.isdir(os.path.join(dicomParentPath, d))]

# Get the name of the latest directory
latest_directory = max(directories, key=lambda d: os.path.getctime(os.path.join(dicomParentPath, d)))

# Ask the user if they want to use the latest directory
use_latest = input(f"Do you want to use the latest directory '{latest_directory}'? (yes/no): ").strip().lower()

if use_latest == 'yes':
    dicomPath = os.path.join(dicomParentPath, latest_directory)
else:
    # Ask the user to choose a directory from the list
    print("List of Directories:")
    for index, directory in enumerate(directories):
        print(f"{index + 1}. {directory}")
    
    choice = int(input("Enter the number of the directory to analyze: "))
    selected_directory = directories[choice - 1]
    dicomPath = os.path.join(dicomParentPath, selected_directory)

print("Location of subject's dicoms: \n" + dicomPath + "\n")

# add the path for the root directory to your python path
sys.path.append(rootPath)

# archive = BidsArchive(tmpPath+'/bidsDataset')
subjID = sys.argv[1]
print(f"\n----Starting MSIT----\n")

# Check if dicomPath exists before using it
if not os.path.exists(dicomPath):
    print(f"Error: Dicom path does not exist: {dicomPath}")
    sys.exit(1)

subj_data_func = image.load_img(os.path.join(dicomPath, '*.nii'))

# Check if the subject's functional data file exists before using it
if not subj_data_func:
    print("Error: No functional data found.")
    sys.exit(1)

# registered mask:
# Specify the parent directory containing ACC mask directories
parent_directory = '/home/rt/rt-fMRI_Neurofeedback_of_ADHD/adhd_rt/registration_folder'

# Get the list of ACC mask directories in the specified parent directory
acc_mask_directories = [d for d in os.listdir(parent_directory) if os.path.isdir(os.path.join(parent_directory, d))]

# Display a numbered list of available ACC mask directories for the user to choose from
print("List of ACC mask directories:")
for index, mask_directory in enumerate(acc_mask_directories):
    print(f"{index + 1}. {mask_directory}")

# Ask the user to choose an ACC mask directory from the list
directory_choice = int(input("Enter the number of the ACC mask directory to use: "))
selected_acc_mask_directory = acc_mask_directories[directory_choice - 1]

# Get the full path to the selected ACC mask directory
acc_mask_directory = os.path.join(parent_directory, selected_acc_mask_directory)

# Get the list of ACC mask files in the selected directory
acc_mask_files = [f for f in os.listdir(acc_mask_directory) if f.endswith('.nii') or f.endswith('.nii.gz')]

# Display a numbered list of available ACC mask files for the user to choose from
print("List of ACC mask files:")
for index, mask_file in enumerate(acc_mask_files):
    print(f"{index + 1}. {mask_file}")

# Ask the user to choose an ACC mask file from the list
file_choice = int(input("Enter the number of the ACC mask file to use: "))
selected_acc_mask_file = acc_mask_files[file_choice - 1]

# Get the full path to the selected ACC mask file
acc_mask = os.path.join(acc_mask_directory, selected_acc_mask_file)

# Check if the selected ACC mask file exists before using it
if not os.path.exists(acc_mask):
    print(f"Error: ACC mask file not found: {acc_mask}")
    sys.exit(1)

#event csv
events = pd.read_table('/home/rt/rt-cloud/projects/adhd_rt/MSIT_Design.csv')

# Read the CSV file using a custom delimiter for the second column
# events = pd.read_csv(eventcsv, delimiter=',', names=['onset', 'duration', 'trial_type'], header=0)

# Now, the data should be properly parsed into separate columns with the index
print(events)

# skull strip subject's func data
subj_skull_stripped = masking.compute_brain_mask(subj_data_func)

"""Parameters of the first-level model

t_r=7(s) is the time of repetition of acquisitions

noise_model=’ar1’ specifies the noise covariance model: a lag-1 dependence

standardize=False means that we do not want to rescale the time series to mean 0, variance 1

hrf_model=’spm’ means that we rely on the SPM “canonical hrf” model (without time or dispersion derivatives)

drift_model=’cosine’ means that we model the signal drifts as slow oscillating time functions

high_pass=0.01(Hz) defines the cutoff frequency (inverse of the time period).
"""

fmri_glm = FirstLevelModel(
    t_r=1.06,
    standardize=False,
    signal_scaling=0,
    smoothing_fwhm=6,
    hrf_model=None,
    drift_model='cosine',
    high_pass=0.01,
)

fmri_glm = fmri_glm.fit(subj_data_func, events)


# design matrix
# conditions array set to be the same as the design matrix number of columns 
design_matrix = fmri_glm.design_matrices_[0]
num_conditions = design_matrix.shape[1]
print('Number of conditions in the design matrix:', num_conditions)

conditions = {"Control": np.zeros(num_conditions), "Interference": np.zeros(num_conditions)}

conditions["Control"][0] = 1
conditions["Control"][1] = -1
conditions["Interference"][0] = -1
conditions["Interference"][1] = 1

# Looking for significantly greater activation during interference condition than control.
inter_minus_con = conditions['Interference'] - conditions['Control']
print(f"First four values in inter_minus_con: {inter_minus_con[:4]}")
print("Length of inter_minus_con:",len(inter_minus_con))


eff_map = fmri_glm.compute_contrast(
    inter_minus_con, output_type="effect_size"
)

z_map = fmri_glm.compute_contrast(inter_minus_con, output_type="z_score")

# ------------------------------------------------------------------------------------------
z_threshold = 0  # Set your threshold value here
# ------------------------------------------------------------------------------------------

positive_zmap_data = np.where(z_map.get_fdata() > z_threshold, z_map.get_fdata(), 0)

# Create a new nibabel NIfTI image with the positive z-map data
positive_zmap_img = nib.Nifti1Image(positive_zmap_data, affine=z_map.affine)


z_map_bin = image.binarize_img(positive_zmap_img, threshold=z_threshold, mask_img=acc_mask)


# Generate a unique filename based on timestamp and a random value
timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
unique_filename = f'acc_mask_{timestamp}.nii.gz'

# Construct the directory path
output_dir = os.path.join(currPath, 'subjects', subjID)

# Ensure the directory exists or create it if it doesn't
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Save the NIfTI image with the unique filename in the subject's folder
output_file_path = os.path.join(output_dir, unique_filename)
nib.save(z_map_bin, output_file_path)

print(" ------------------------------------------------------ ")
print(f"Threshold for inclusion in binary z-map is {z_threshold}")
print(" ------------------------------------------------------ ")

try:
    nib.save(z_map_bin, output_file_path)
    print(f"ROI mask saved successfully: {output_file_path}")
except Exception as e:
    print(f"Error: Unable to save ROI mask: {e}")

# IN CASE YOU WANT TO MAKE SOME PLOTS: 
# mean_img = mean_img(subj_data_func)

#plot_stat_map(
#    z_map_bin,
#    bg_img=mean_img,
#    threshold=1,
#    display_mode="z",
#    cut_coords=3,
#    black_bg=True,
#    title=f"Inter Minus Con (Z>{z_threshold})",
#)
#plt.show()

# Save to current subject's folder



